<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><base href="../../"><link rel="stylesheet" href="dmdoc.css"><title>code/__HELPERS/turfs.dm - /tg/ Station 13</title></head><body><header><a href="index.html">/tg/ Station 13</a> - <a href="index.html#modules">Modules</a> - <a href="index.html#types">Types</a></header><main><h1>code/__HELPERS/turfs.dm <a href="https://github.com/tgstation/tgstation/blob/c41b333c9bc46606d2c5d5b517f7836d5953fbfd/code/__HELPERS/turfs.dm"><img src="git.png" width="16" height="16" title="code/__HELPERS/turfs.dm"></a></h1><table class="summary" cellspacing="0"><tr><th>/proc/<a href="global.html#proc/get_teleport_loc">get_teleport_loc</a></th><td>Returns location. Returns null if no location was found.</td></tr><tr><th>/proc/<a href="global.html#proc/get_atom_on_turf">get_atom_on_turf</a></th><td>Returns the top-most atom sitting on the turf.
For example, using this on a disk, which is in a bag, on a mob,
will return the mob because it's on the turf.</td></tr><tr><th>/proc/<a href="global.html#proc/get_edge_target_turf">get_edge_target_turf</a></th><td>Returns the turf located at the map edge in the specified direction relative to target_atom used for mass driver</td></tr><tr><th>/proc/<a href="global.html#proc/get_ranged_target_turf_direct">get_ranged_target_turf_direct</a></th><td>Get ranged target turf, but with direct targets as opposed to directions</td></tr><tr><th>/proc/<a href="global.html#proc/get_offset_target_turf">get_offset_target_turf</a></th><td>returns turf relative to target_atom offset in dx and dy tiles, bound to map limits</td></tr><tr><th>/proc/<a href="global.html#proc/get_turf_pixel">get_turf_pixel</a></th><td>Lets the turf this atom's <em>ICON</em> appears to inhabit
it takes into account:
Pixel_x/y
Matrix x/y
NOTE: if your atom has non-standard bounds then this proc
will handle it, but:
if the bounds are even, then there are an even amount of &quot;middle&quot; turfs, the one to the EAST, NORTH, or BOTH is picked
this may seem bad, but you're at least as close to the center of the atom as possible, better than byond's default loc being all the way off)
if the bounds are odd, the true middle turf of the atom is returned</td></tr><tr><th>/proc/<a href="global.html#proc/get_visual_offset">get_visual_offset</a></th><td>Returns how visually &quot;off&quot; the atom is from its source turf as a list of x, y (in pixel steps)
it takes into account:
Pixel_x/y
Matrix x/y
Icon width/height</td></tr><tr><th>/proc/<a href="global.html#proc/pixel_offset_turf">pixel_offset_turf</a></th><td>Takes a turf, and a list of x and y pixel offsets and returns the turf that the offset position best lands in</td></tr><tr><th>/proc/<a href="global.html#proc/parse_caught_click_modifiers">parse_caught_click_modifiers</a></th><td>Returns a turf based on text inputs, original turf and viewing client</td></tr><tr><th>/proc/<a href="global.html#proc/get_loc_from_mousepos">get_loc_from_mousepos</a></th><td>Converts mouse-pos control coordinates to a specific turf location on the map.</td></tr><tr><th>/proc/<a href="global.html#proc/screen_loc_to_turf">screen_loc_to_turf</a></th><td>Almost identical to the params_to_turf(), but unused (remove?)</td></tr><tr><th>/proc/<a href="global.html#proc/spiral_range_turfs">spiral_range_turfs</a></th><td>similar function to RANGE_TURFS(), but will search spiralling outwards from the center (like the above, but only turfs)</td></tr><tr><th>/proc/<a href="global.html#proc/get_random_station_turf">get_random_station_turf</a></th><td>Returns a random turf on the station</td></tr><tr><th>/proc/<a href="global.html#proc/get_safe_random_station_turf">get_safe_random_station_turf</a></th><td>Returns a random turf on the station, excludes dense turfs (like walls) and areas that have valid_territory set to FALSE</td></tr><tr><th>/proc/<a href="global.html#proc/get_safe_random_station_turf_equal_weight">get_safe_random_station_turf_equal_weight</a></th><td>Returns a random department of areas to pass into get_safe_random_station_turf() for more equal spawning.</td></tr><tr><th>/proc/<a href="global.html#proc/valid_build_direction">valid_build_direction</a></th><td>Checks whether the target turf is in a valid state to accept a directional construction
such as windows or railings.</td></tr><tr><th>/proc/<a href="global.html#proc/is_type_on_turf">is_type_on_turf</a></th><td>Checks whether or not a particular typepath or subtype of it is present on a turf</td></tr><tr><th>/proc/<a href="global.html#proc/get_blueprint_data">get_blueprint_data</a></th><td>get_blueprint_data
Gets a list of turfs around a central turf and gets the blueprint data in a list
Args:</td></tr></table></main><footer>tgstation.dme <a href="https://github.com/tgstation/tgstation/tree/c41b333c9bc46606d2c5d5b517f7836d5953fbfd">c41b333</a> (master) â€” <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.11.0</a></footer></body></html>